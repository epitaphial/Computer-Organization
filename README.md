# 计组考前懵逼释疑     *<u>by Curled</u>*

[TOC]









## 第一章 绪论



#### 哈佛结构和冯诺依曼结构有什么主要的不同？



冯·诺依曼结构**将程序指令存储器和数据存储器合并在一起**，指令存储地址和数据存储地址指向**同一个存储器的不同物理位置**。

使用冯·诺伊曼结构的中央处理器有很多。如Intel公司的80X86、ARM公司的ARM7、MIPS公司的MIPS等都采用了冯·诺伊曼结构。

而哈佛结构是一种**将程序指令存储和数据存储分开的存储器结构**。目前使用哈佛结构的中央处理器也有很多，如MOTOROLA公司的MC68系列、Zilog公司的Z8系列和ARM公司的ARM9、ARM10和ARM11等。



#### 计算机的总线有哪些分类



**系统总线、CPU内总线、外部总线（通信总线）**。

其中，系统总线包含**地址线、数据线和控制信号线**，CPU内总线主要连接各寄存器和ALU，外部总线用于计算机系统之间通信。

数据总线为**双向**三态逻辑，线宽(位数)表示了总线数据传输的能力。

地址总线为**单向**三态逻辑，线宽决定了系统的寻址能力。

控制总线：用来传输控制或状态信号。它根据使用条件不同，**有的为单向，有的为双向传输，有的是三态，有的是非三态**。



#### 什么是计算机的位？什么是字长？



计算机的位一般指地址总线的宽度。

基本字长指计算机在同一时间中处理二进制数的位数，通常称为CPU的位。前者是寻址能力，后者是数据处理能力。而基本字长又决定了寄存器运算器和数据总线的位数。



#### 基数，基本符号，位权。



基本符号是一个进制允许用的符号。基数是所有基本符号的个数，通常，x进制，就说明x是这个进制的基数。位权是不同数位的权值。



## 第二章 数据的表示



#### IEEE754浮点数表示中，指数偏移值是真值+127，而不是128，表示的范围为1~254.



单精度浮点数的指数域是8个bit，-128\~127加上127之后范围变为-1\~254。

对-128来说，补码为1000 000（注意不是0000000，因为-128没有反码！否则和0重复了）。加上127后为255（即E=255），如果此时同时M为0的话，表示为±∞（与符号位有关），而对于0，如果此时M为0，则真值为±0，如过此时E=255，M不为0时，则此时真值不是一个数，即NAN。

参考：https://blog.csdn.net/a7515780/article/details/60469155

https://baike.baidu.com/item/IEEE%20754/3869922?fromtitle=IEEE754%E6%A0%87%E5%87%86&fromid=10427270&fr=aladdin



#### 什么是规约化浮点数，什么是非规约化浮点数？规约化浮点数的表示范围与精度取决什么？



如果浮点数中指数部分的编码值在0<exponent<2^e-2之间，且在科学表示法的表示方式下，分数 (fraction) 部分最高有效位（即整数字）是1，那么这个浮点数将被称为**规约形式的浮点数**。

“规约”是指用唯一确定的浮点形式去表示一个值。如果浮点数的指数部分的编码值是0，分数部分非零，那么这个浮点数将被称为**非规约形式的浮点数**。一般是某个数字相当接近零时才会使用非规约型式来表示。

IEEE 754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1。采用浮点数表示时，表示范围取决于**阶码**的位数，精度取决于**尾数**的位数，**数符**决定浮点数的正负。

计算参考：https://blog.csdn.net/qq_29287973/article/details/78914821



## 第三章 指令系统



#### 什么是机器字长？什么是指令字长？各有什么关系？



机器字长：CPU能直接处理的二进制数据的位数，一般是字节字长的整数倍。字长越长，运算精度就越高。

指令字长：指令字的长度取决于操作码的长度、操作数地址的长度和操作数地址的个数。这个是由指令格式决定的：指令由操作码OP+地址码AD构成。为了充分利用存储空间，指令字长也为字节字长的整数倍。
关系：**没有固定的关系，可以等于，也可以大于小于**。



#### 什么是单双字长指令？什么是单双操作数指令？双操作数指令一定是二地址指令吗？



单双字长指令，仅仅用于反应**指令字长**和**机器字长**之间的关系，量词反应指令字长对机器字长的倍数。执行完成后，指令地址要加上相应的倍数。

单双操作数指令。单操作数指令指的是由OP和目标地址构成的指令，而双操作数指令指的是由OP和源地址，目标地址构成的指令。与之平行的还有：转移指令、转子指令、子程序返回指令、条件码操作指令。

一地址指令还包括隐含操作数地址的指令，如双操作数指令，指定一寄存器（通常为累加寄存器），用来提供操作数并存放运算结果。
也就是说，n地址指令只**包含**n个操作数，但不一定只**处理**n个操作数。 



#### 什么是访问储存器的方式？什么是寻址方式？常见的寻址方式有哪些？



访问储存器的方式有以下三种：

**1.地址指定方式 2.相连存储方式 3.堆栈存取方式**

几乎所有的计算机，在主存中都采用地址指定方式。

寻址方式：当采用**地址指定方式**，形成操作数或指令地址，叫做寻址方式。

寻址方式主要分为**指令寻址**方式和**数据寻址**方式 。

指令寻址方式分为：**顺序寻址**方式和**转移寻址**方式。

顺序寻址方式必须用程序计数器PC来记数指令的顺序号，转移寻址方式的实质是改变这一顺序号，即改变PC的值，当程序转移后，将按新的指令地址继续顺序执行。

对操作数寻址来说，分为：

1.**立即寻址方式**	直接给出操作数	缺陷：操作数包含在指令内，数值长度受到限制。

2.**直接寻址（绝对寻址）**	直接给出存有操作数的存储器地址	缺点：绝对地址不能修改。当给出的是寄存器号时，此时称为寄存器直接寻址。

3.**间接寻址**	给出存有操作数地址的储存单元的地址。	特点：支持程序循环，但两次访存，速度较慢。	当给出的是存有操作数地址的寄存器号时，此时称为寄存器间接寻址。此时一次访存，速度更快。

4.**变址寻址**		给出变址寄存器号和基地址，操作数的**地址**为寄存器内容与基地址的和。

5.**基址寻址**	1.把整个存储空间分为若干段，每段的首地址存在一个基址寄存器中，指令直接给出段内的位移量2.由于程序运行的局部性，位移量位数不必全字长。基址寄存器的位数应该与主存空间相等，位移量位数应该和段长度相等。

6.**相对寻址**	把程序计数器PC的内容加上指令格式中的形式地址D，形成操作数的有效地址。	特点：用来实现分支、循环。

7.**堆栈寻址**	对串联堆栈（硬堆栈）来说，这是用寄存器做成的堆栈，压栈弹栈均由硬件支持，直接取出或压入寄存器，此时栈顶固定，不需要堆栈指针，速度比较快，长度受寄存器数目的限制，弹栈为破坏性弹栈。对存储器堆栈（软堆栈）来说，此时堆栈是利用一部分主存区域，此时长度灵活。但数据不能像硬堆栈一样从一个单元直接移动到另一个单元。而是采用移动堆栈顶部的方法，设置一个栈针**SP**来指示栈顶的移动情况。



#### 什么是大端序（大数端），什么是小端序（小数端）？如何区分小环移和大环移？



大端序：数据的最低**字节**存储在**高地址**。

小端序：数据的最低**字节**存储在**低地址**。

常见的大端序：网络字节序

小环移左移：C标志和最低位都接受最高位

大环移左移：最低位接受C标志，C标志接受最高位



## 第四章 运算器与运算方法



#### 什么是串行进位？什么是先行进位？



串行进位必须等到地位加法做完，才能等到送来的进位，而先行（并行）进位可以把进位信号同时送到各位全加器的进位输入端。

以四位先行加法器为例子。C1 = X1Y1 + (X1+Y1)C0。定义 Pi = Xi+Yi为进位传递函数，定义 Gi = XiYi 为进位产生函数。

则四位先行(快速)进位链的逻辑表达式为：

C1 = G1 + P1C0

C2 = G2 + P2C1 = G2 + P2G1 + P2P1C0

C3 = G3 + P3C2 = G3 + P3G2 + P3P2G1 + P3P2P1C0

C4 = G4 + P4C3 = G4 + P4G3 + P4P3G2 + P4P3P2G1 + P4P3P2P1C0





#### 什么是上溢和下溢？如何判断溢出？



上溢指运算结果超过了允许的最大正数，下溢指结果超过了允许的最小负数。常用的溢出判别法有：

1.进位判别法

两个**补码**做加法运算，最高数值位向符号位的进位C，与符号位产生的进位输出Cs，不相同的时候溢出。

2.单符号法

溢出只发生在同号数，当同号数相加，运算结果与原来的符号相反，一定产生了溢出。

3.双符号法

数符用两个相同的符号位表示，正数的双符号位为00，负数为11。
两个正数符号位的运算为00+00=00时,结果不溢出;
两个正数符号位的运算为00+00+1=01时,结果上溢;
两个负数符号位运算为11+11+1 = 11时，结果不溢出;
两个负数的双符号位的运算为11+11 = 10时，结果下溢。
OVR = S1 xor S2 ，此时不仅能指示溢出，S1还始终能指示结果的正负。



#### 浮点加减法是如何实现的？



浮点加减法分为5个步骤：

**第1步：对阶，调整尾数**

阶码的比较通过两阶码的减法来实现，对阶是使原数中**较大**的阶码成为两数的公共阶码。
注意事项：尾数右移时，分两种情况：1.原码形式：符号位不参与移位，空出位补0；2.补码形式：符号位与数值位一同右移，空出位填补符号位的值。

**第2步：尾数加减**

**第3步：尾数规格化**

当浮点数的尾数用补码表示，加减运算采用双符号位，则规格化形式的尾数应如下格式：
尾数为正数：001x……x
尾数为负数：110x……x
规格化方法有两种，分为**左规**和**右规**。
尾数右移一位，阶码加一，称为**右规**。当尾数在加减法运算中产生溢出的时候，采用右规的方法。
符号位不动，数值位逐次左移，阶码逐次减1，直到满足规格化形式的尾数，即最高数值位与符号位不同值为止的方法，称为**左规**。当尾数的绝对值小于二进制的0.1时采用，此时补码形式的尾数表现为最高数值位与符号位同值。

**第4步：尾数的舍入处理**

① 0舍1入法
② 恒置1法
③ 恒舍法

**第5步：阶码溢出判断** 

一个浮点运算器主要由两个定点运算器组成，分别为阶码运算部件，尾数运算部件。阶码运算部件只需实现加减，而尾数运算部件需要实现加减乘除、移位、规格化判断。



#### 原码一位乘法



来由：手算乘法的方法中，需要对多个数据同时相加，且得到的结果长度往往是原数据的两倍，在计算机的实现中，这很难做到。于是采用原码一位乘法，把n位乘转化为n次“累加和移位”。

![逻辑电路框图](C:\Users\Curled\Desktop\计组迷茫点\图片1.png)



## 第五章 控制器



#### <span id = "psw">关于PSW寄存器</span>



状态标志寄存器，FLAG（全称：EFLAGS Register），又称程序状态寄存器（它的内容是Program Status Word，PSW），主要用于反映处理器的状态和ALU运算结果的某些特征及控制指令的执行。

|      |      |      |      | OF   | DF   | IF   | TF   | SF   | ZF   |      | AF   |      | PF   |      | CF   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

6个状态标志位为：

- 进位标志位（CF）：
- 辅助进位标志位（AF）；
- 溢出标志位（OF）：
- 零标志位（ZF）；
- 符号标志位（SF）；
- 校验标志位（PF）；

3个控制标志为：

- 方向标志（DF），表示串操作指令中字符串操作的方向。
- 中断允许标志位（IF），表示CPU是否能够相应外部的可屏蔽中断请求。
- 陷阱标志位（TF），为了方便程序的调试，使处理器的执行进入单步方式而设置的控制标志位。



#### 控制器中，哪些寄存器是用户可见的？哪些是用户不可见的？



对**用作处理的寄存器**来说，所有的通用寄存器组都是用户可见的，都可以编程访问，可以存放操作数和操作数地址。

对**用于控制的寄存器**来说，指令寄存器IR是不可见的，用于存放现行指令，以及输出用于产生控制信号的序列。程序计数器PC是可见的，提供读取指令的地址，又叫指令指针IP。程序状态字寄存器是用户可见的，内容表示现行程序的状态，具体见[关于PSW寄存器](#psw)。



#### 转移指令的基本原理？



无条件转移指令：又称必转，不受任何条件的约束，直接把程序指向新的位置并执行，一般为JMP

条件转移：必须受到条件的约束，条件由某些标志位或这些标志位的逻辑运算为依据，单个标志位的条件转移指令的转移条件是上次运算结果的某些标志，如进位、零标志、结果溢出标志等。

根据单个标志位的状态判断转移的指令（DEST为目的地址destination的缩写）

| 指令             | 转移条件 | 说明                |
| ---------------- | -------- | ------------------- |
| **JC DEST**      | **CF=1** | **有进位/借位**     |
| **JNC DEST**     | **CF=0** | **无进位/借位**     |
| **JE/JZ DEST**   | **ZF=1** | **相等/等于零**     |
| **JNE/JNZ DEST** | **ZF=0** | **不相等/不等于零** |
| **JS DEST**      | **SF=1** | **是负数**          |
| **JNS DEST**     | **SF=0** | **是正数**          |
| **JO DEST**      | **OF=1** | **有溢出**          |
| **JNO DEST**     | **OF=0** | **无溢出**          |
| **JP/JPE DEST**  | **PF=1** | **有偶数个“1”**     |
| **JNP/JPO DEST** | **PF=0** | **有奇数个“1”**     |

根据两个无符号数的比较结果判断转移的指令

| 指令         | 转移条件      | 含义        | 英文表述                        |
| ------------ | ------------- | ----------- | ------------------------------- |
| JA/JNBE DEST | CF=0 AND ZF=0 | 无符号数A>B | JMP above (not below or equal)  |
| JAE/JNB DEST | CF=0          | 无符号数A≥B | JMP above or equal (not below ) |
| JB/JNAE DEST | CF=1          | 无符号数A<B | JMP blow (not above or equal)   |
| JBE/JNA DEST | CF=1 OR ZF=1  | 无符号数A≤B | JMP blow or equal (not above)   |

根据两个有符号数的比较结果判断转移的指令

| 指令         | 转移条件       | 含义        | 英文表述                        |
| ------------ | -------------- | ----------- | ------------------------------- |
| JG/JNLE DEST | SF=OF AND ZF=0 | 有符号数A>B | JMP greater (not less or equal) |
| JGE/JNL DEST | SF=OF OR ZF=1  | 有符号数A≥B | JMP greater or equal (not less) |
| JL/JNGE DEST | SF≠OF AND ZF=0 | 有符号数A<B | JMP less (not greater or equal) |
| JLE/JNG DEST | SF≠OF OR ZF=1  | 有符号数A≤B | JMP less or equal (not greater) |



#### 流水线的基本原理？

串行执行指令 ：没有充分利用执行部件的并行性，指令执行效率低。
流水线方式执行指令：多条指令的执行相互重叠起来，提高CPU执行指令的效率。

一条指令的执行可被分成若干个阶段：
取指令(IF) ：根据PC值从存储器取出指令。
指令译码(ID) ：产生指令执行所需的控制信号。
取操作数(OF) ：读取存储器操作数或寄存器操作数。
执行(EX) ：对操作数完成指定操作。
写回(WB) ：将操作结果写入存储器或寄存器。

一个x段指令的流水线，完成y条指令。
流水执行，需要x+y-1个周期。
串行执行，需要x*y个周期

流水线方式并不能缩短单条指令的执行时间，但提高了指令的吞吐率。
流水段个数：最复杂指令的功能段个数。
流水段长度：最复杂功能段的操作所用的时间。



## 第六章 存储系统





#### 什么是按字编址？什么是按字节编址？



首先，我们要知道什么是编址。

百度百科的定义是，编址：存储器是由一个个存储单元构成的，为了对存储器进行有效的管理，就需要对各个存储单元编上号，即给每个单元赋予一个地址码，这叫编址。经编址后，存储器在逻辑上便形成一个线性地址空间。

所以两种编址方式，一种是以字长为一个单元进行编址，一种是以字节为一个单元进行编址。所以主存的地址空间（可以理解为容量），在计算的时候，我们要先计算出单元的数量（容量除以每个单元的容量），所得即为寻址范围的大小x，而寻址范围为区间0~x-1。

参考：https://blog.csdn.net/u012468263/article/details/77920234



#### 按存取方式分类，有哪些存储器？分别有哪些特点？



**随机访问：存取时间与物理地址无关**

***随机存储***器（R\W）（RAM）
CPU和I/O设备在任意时刻都可按地址随机访问任一存储单元。访问各单元读写时间相同，与地址无关。
半导体存储器一般属于RAM存储器，主存与cache采用随机访问的存取方式，CPU可直接编程访问。分为SRAM\DRAM两种。

***只读存储***器（R） （ROM）
只能读出不能写入。
应用：BIOS、CPU用ROM固化微程序。用ROM做辅存：CD-ROM。

**串行访问：存取时间与 物理地址有关**

***顺序存取***存储器 磁带 （SAM）
特点：信息只能按某种顺序存放或读出，存取时间取决于信息的存放位置。
存储容量大；每位价格低；存取速度慢。仅适用于外存。

***直接存取***存储器 磁盘 （DAM）
先选择信息的较小局部区域，然后再顺序存取。
容量大，速度介于SAM和RAM之间，主要用于辅存。
